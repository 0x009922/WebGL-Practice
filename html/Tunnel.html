<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Tunnel</title>
		<style>
			body { margin: 0; overflow: hidden; }
			canvas { width: 100vw; height: 100vh; }
		</style>
	</head>
	<body>
		<script src="../js/three.js"></script>
		<script>
			const _camLookPos = -7;
			const _camLookFactor = 2;
			const _camPos = -2;
			const _camPosFactor = -1;
			const _camTargetSpeed = 2;
			const _camRelaxationSpeed = 0.5;
			const _normalFOV = 55;
			const _minFOV = 10;
			const _maxFOV = 130;
			const _fovTargetSpeed = 2;
			const _fovRelaxationSpeed = 0.5;

			const _ringSegments = 30;
			const _randomNumR = 0.3;
			const _randomNumZ = 0.5;
			const _sectionLength = [0.5, 2];
			const _tunnelLength = 35;
			const _speed = 5;

			const _tunnelColor = 0;
			const _lightColor = 0x00ff7f;
			const _fogColor = 0x00ff7f;
			const _antialias = false;

			class Tunnel {
				constructor() {
					let rings = [generateRing(1)];
					this.sections = [];
					let i = 0;
					let totalLength = 0;
					while (totalLength < _tunnelLength) {
						rings.push(generateRing(i % 2));

						let len = between(_sectionLength, Math.random());
						this.sections.push(new Section(
							rings[i],
							rings[i + 1],
							len
						));

						i++;
						totalLength += len;
					}

					this.x = 0;
				}

				update(delta) {
					this.x += _speed * delta;

					let currentLength, z = this.x;
					for (let i = 0; i < this.sections.length; i++) {
						this.sections[i].zPos = z;
						if (i < this.sections.length - 1) {
							z -= this.sections[i].length / 2 + this.sections[i + 1].length / 2;
						}
					}
					currentLength = -z;

					if (this.sections[0].zPos > this.sections[0].length / 2) {
						this.sections[0].remove();
						this.x -= this.sections[0].length / 2 + this.sections[1].length / 2;
						this.sections.splice(0, 1);
					}

					let i = this.sections.length - 1;
					while (currentLength < _tunnelLength) {
						let nLen = between(_sectionLength, Math.random());
						this.sections.push(new Section(
								this.sections[i].ring2,
								generateRing((this.sections[i].ring2.n + 1) % 2),
								nLen
							)
						);
						z -= this.sections[i].length / 2 + nLen / 2;
						this.sections[++i].zPos = z;
						currentLength += nLen;
					}
				}
			}

			class Section {
				constructor() {
					this.meshIn = null;
					if (arguments[0]) {
						this.set(arguments[0], arguments[1], arguments[2]);
					}
				}

				set(ring1, ring2, length) {
					if (this.meshIn) {
						this.remove();
					}

					this.ring1 = ring1;
					this.ring2 = ring2;
					this.length = length;

					let facesTemplate = [
						[
							0, 1, 2, 1, 2, 3
						],
						[
							0, 2, 3, 0, 1, 3
						]
					];

					let gmy = new THREE.Geometry();
					for (let i = 0; i < _ringSegments; i++) {
						gmy.vertices.push
						(

							new THREE.Vector3(
								ring1[i].x,
								ring1[i].y,
								ring1[i].z + length / 2
							),
							new THREE.Vector3(
								ring1[(i + 1) % _ringSegments].x,
								ring1[(i + 1) % _ringSegments].y,
								ring1[(i + 1) % _ringSegments].z + length / 2
							),
							new THREE.Vector3(
								ring2[i].x,
								ring2[i].y,
								ring2[i].z - length / 2
							),
							new THREE.Vector3(
								ring2[(i + 1) % _ringSegments].x,
								ring2[(i + 1) % _ringSegments].y,
								ring2[(i + 1) % _ringSegments].z - length / 2
							)

						);

						let j = i*4;
						let t = facesTemplate[i%2];
						gmy.faces.push(
							new THREE.Face3(j + t[0], j + t[1], j + t[2]),
							new THREE.Face3(j + t[3], j + t[4], j + t[5])
						);
					}
					gmy.computeFaceNormals();

					let mtrlIn = new THREE.MeshPhysicalMaterial({
						color: _tunnelColor,
						clearCoat: 0.5,
						clearCoatRoughness: 1,
						reflectivity: 0.5,
						side: THREE.DoubleSide
					});

					this.meshIn = new THREE.Mesh(gmy, mtrlIn);

					scene.add(this.meshIn);
				}

				remove() {
					scene.remove(this.meshIn);
				}

				get zPos() {
					return this.meshIn.position.z;
				}
				set zPos (value) {
					this.meshIn.position.z = value;
				}
			}

			class MouseHandler {
				constructor() {
					this.target = new THREE.Vector2();
					this.current = new THREE.Vector2();
					this.targetSpeed = _camTargetSpeed;

					this.tFov = _normalFOV;
					this.cFov = _normalFOV;
					this.fovSpeed = _fovTargetSpeed;

					document.body.addEventListener("mousemove", this.onMove.bind(this), false);
					document.body.addEventListener("mousedown", this.onDown.bind(this), false);
					document.body.addEventListener("mouseup", this.onUp.bind(this), false);
					document.body.addEventListener("mouseleave", this.onLeave.bind(this), false);
					document.body.oncontextmenu = () => false;
					this.mousestatus = 0;
				}

				onMove(e) {
					if (this.mousestatus > 0 && this.mousestatus < 4)
						this._setTarget(e);
				}

				onDown(e) {
					this.mousestatus += e.which;
					this._setTarget(e);
				}

				onUp(e) {
					this.mousestatus -= e.which;
					if (this.mousestatus < 0) this.mousestatus = 0;
				}

				onLeave(e) {
					this.mousestatus = 0;
				}

				_setTarget(e) {
					this.target.set(
						(e.pageX / window.innerWidth * 2 - 1),
						-(e.pageY / window.innerHeight * 2 - 1)
					);
				}

				update(delta) {
					let fovSpeed, camSpeed;

					if (this.mousestatus > 0 && this.mousestatus < 4) {
						fovSpeed = _fovTargetSpeed;
						camSpeed = _camTargetSpeed;
						this.tFov = (this.mousestatus == 1) ? _minFOV : _maxFOV;
					} else {
						fovSpeed = _fovRelaxationSpeed;
						camSpeed = _camRelaxationSpeed;
						this.target.set(0, 0);
						this.tFov = _normalFOV;
					}

					this.current.x += (this.target.x - this.current.x) * delta * camSpeed;
					this.current.y += (this.target.y - this.current.y) * delta * camSpeed;
					this.cFov += (this.tFov - this.cFov) * delta * fovSpeed;

					camera.position.set(
						this.current.x * _camPosFactor,
						this.current.y * _camPosFactor,
						_camPos
					);
					camera.lookAt(
						this.current.x * _camLookFactor,
						this.current.y * _camLookFactor,
						_camLookPos
					);
					camera.fov = this.cFov;
					camera.updateProjectionMatrix();
				}
			}

			function init() {
				renderer = new THREE.WebGLRenderer({
					antialias: _antialias
				});
				renderer.setPixelRatio( window.devicePixelRatio );
	      renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(_fogColor, 1);
	      document.body.appendChild(renderer.domElement);
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(_fogColor, 0, _tunnelLength);
	      camera = new THREE.PerspectiveCamera(
					45,
					window.innerWidth / window.innerHeight,
					0.1,
					50
				);
				clock = new THREE.Clock();
				elapsed = Math.random() * 20;

				let light1 = new THREE.PointLight(_lightColor, 1, 100, 2);
				light1.position.set(0, 0, -60);
				scene.add(light1);

				tunnel = new Tunnel();
				handler = new MouseHandler();
			}

      function animate() {
      	requestAnimationFrame(animate);

				let delta = clock.getDelta();
				if (delta > 100) return;
				elapsed += delta;
				currentRadius = 1.5 + 0.1 * Math.sin(elapsed) +
															0.05 * Math.sin(elapsed*1.2) +
															0.05 * Math.sin(elapsed*1.3) +
															0.05 * Math.sin(elapsed*0.5) +
															0.05 * Math.sin(elapsed*1.9);
				//updateCamera(delta);
				tunnel.update(delta);
				handler.update(delta);

      	renderer.render(scene, camera);
      }

			function generateRing(n) {
				let res = [];
				res.n = n;
				const da = Math.PI * 2 / _ringSegments;
				for (let i = 0, a = (n == 0) ? 0 : da / 2; i < _ringSegments; i++, a += da) {
					let r = currentRadius - Math.random() * _randomNumR;
					let v = new THREE.Vector3(
						Math.cos(a) * r,
						Math.sin(a) * r,
						(Math.random() * 2 - 1) * _randomNumZ
					);
					res.push(v);
				}
				return res;
			}

			function between(pair, n) {
        return n * (pair[1] - pair[0]) + pair[0];
      }

			var scene, camera, renderer, clock, handler;
			var elapsed;
			var tunnel;

			var currentRadius = 1.5;

			init();
      animate();
		</script>
	</body>
</html>
