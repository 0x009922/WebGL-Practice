<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Tunnel</title>
		<style>
			body { margin: 0; overflow: hidden; }
			canvas { width: 100vw; height: 100vh; }
			.meetingContainer {

			}
		</style>
	</head>
	<body>
		<script src="../js/three.js"></script>
		<script>
			const _camLookPos = -7;
			const _camLookFactor = 2;
			const _camPos = -2;
			const _camPosFactor = -1;
			const _camTargetSpeed = 2;
			const _camRelaxationSpeed = 1;
			const _normalFOV = 35;
			const _minFOV = 10;
			const _maxFOV = 70;
			const _fovTargetSpeed = 2;
			const _fovRelaxationSpeed = 1;

			const _ringSegments = 60;
			const _randomNumR = 0.3;
			const _randomNumZ = 0.3;
			const _sectionLength = [0.5, 2];
			const _tunnelLength = 65;
			const _speed = 5;
			const _rotationSpeed = 0.2;

			const _secSize = _ringSegments * 6 * 3;
			const _bufferSize = _secSize * 1000;

			const _tunnelColor = 0;
			const _lightColor = 0x00ff7f;
			const _fogColor = 0x00ff7f;
			const _antialias = false;

			class Tunnel {
				constructor() {
					this.buffer = new BufferMaster();

					this.rings = [generateRing(1)];
					this.secs = [];
					let i = 0;
					let totalLength = 0;
					let z = 0;
					while (totalLength < _tunnelLength) {
						this.rings.push(generateRing(i % 2));
						let len = between(_sectionLength, Math.random());
						this.secs.push({length: len, start: z});
						this.buffer.push(generateSectionVerts(
							this.rings[i],
							this.rings[i + 1],
							len
						), z - len / 2);

						z -= len;
						i++;
						totalLength += len;
					}

					let g = new THREE.BoxGeometry(1, 1, 1);

					let mtrl = new THREE.MeshPhysicalMaterial({
						color: _tunnelColor,
						clearCoat: 0.5,
						clearCoatRoughness: 1,
						reflectivity: 0.5,
						side: THREE.DoubleSide
					});
					this.buffer.update();
					this.mesh = new THREE.Mesh(this.buffer.geometry, mtrl);

					scene.add(this.mesh);
					scene.add(new THREE.AxesHelper(15, 15, 15));
				}

				update(delta) {
					this.mesh.position.z += _speed * delta;
					this.mesh.rotation.z += _rotationSpeed * delta;
					let currentLength = this.secs.reduce((s, c) => (s + c.length), 0);

					if (this.mesh.position.z > this.secs[0].length) {
						this.mesh.position.z -= this.secs[0].length;
						currentLength -= this.secs[0].length;
						this.buffer.remove(1, this.secs[0].length);
						for (let i of this.secs) i.start += this.secs[0].length;
						this.secs.splice(0, 1);
						this.rings.splice(0, 1);
					}

					let lastSec = this.secs[this.secs.length - 1];
					while (this.mesh.position.z - currentLength > -_tunnelLength) {
						let rcount = this.rings.length;
						let nLen = between(_sectionLength, Math.random());

						this.rings.push(generateRing( (this.rings[rcount - 1].n + 1) % 2 ));
						lastSec = {
							length: nLen,
							start: lastSec.start - lastSec.length
						};
						this.secs.push(lastSec);

						this.buffer.push(
							generateSectionVerts(
								this.rings[rcount - 1],
								this.rings[rcount],
								nLen
							),
							lastSec.start - nLen / 2
						);
						currentLength += nLen;
					}

					this.buffer.update();
				}
			}

			class BufferMaster {
				constructor() {
					this.geometry = new THREE.BufferGeometry();
					this.positions = new Float32Array(_bufferSize);

					this.geometry.addAttribute(
						"position",
						new THREE.BufferAttribute(this.positions, 3)
					);

					this.count = 0;
					this.needUpdate = false;
				}

				remove(n, remlen) {
					let positions = this.geometry.getAttribute("position").array;

					this.count -= n;
					for (let i = 0, d = n * _secSize; i < this.count * _secSize; i++) {
						positions[i] = positions[i + d];
						if (i % 3 == 2) {
							positions[i] += remlen;
						}
					}

					this.needUpdate = true;
				}

				push(verts, z) {
					let positions = this.geometry.getAttribute("position").array;

					let bi = this.count * _secSize;
					for (let i = 0; i < verts.length; i++) {
						for (let j = 0; j < 3; j++) {
							positions[bi++] = verts[i][j].x;
							positions[bi++] = verts[i][j].y;
							positions[bi++] = verts[i][j].z + z;
						}
					}

					this.count++;
					this.needUpdate = true;
				}

				update() {
					if (this.needUpdate) {
						this.geometry.computeBoundingSphere();
						this.geometry.computeVertexNormals();
						this.geometry.getAttribute("position").needsUpdate = true;
						this.geometry.setDrawRange(0, this.count * _secSize / 3);
						this.needUpdate = false;
					}
				}
			}

			class MouseHandler {
				constructor() {
					this.target = new THREE.Vector2();
					this.current = new THREE.Vector2();
					this.targetSpeed = _camTargetSpeed;

					this.tFov = _normalFOV;
					this.cFov = _normalFOV;
					this.fovSpeed = _fovTargetSpeed;

					document.body.addEventListener("mousemove", this.onMove.bind(this), false);
					document.body.addEventListener("mousedown", this.onDown.bind(this), false);
					document.body.addEventListener("mouseup", this.onUp.bind(this), false);
					document.body.addEventListener("mouseleave", this.onLeave.bind(this), false);
					document.body.oncontextmenu = () => false;
					this.mousestatus = 0;
				}

				onMove(e) {
					if (this.mousestatus > 0 && this.mousestatus < 4)
						this._setTarget(e);
				}

				onDown(e) {
					this.mousestatus += e.which;
					this._setTarget(e);
				}

				onUp(e) {
					this.mousestatus -= e.which;
					if (this.mousestatus < 0) this.mousestatus = 0;
				}

				onLeave(e) {
					this.mousestatus = 0;
				}

				_setTarget(e) {
					this.target.set(
						(e.pageX / window.innerWidth * 2 - 1),
						-(e.pageY / window.innerHeight * 2 - 1)
					);
				}

				update(delta) {
					let fovSpeed, camSpeed;

					if (this.mousestatus > 0 && this.mousestatus < 4) {
						fovSpeed = _fovTargetSpeed;
						camSpeed = _camTargetSpeed;
						this.tFov = (this.mousestatus == 1) ? _minFOV : _maxFOV;
					} else {
						fovSpeed = _fovRelaxationSpeed;
						camSpeed = _camRelaxationSpeed;
						this.target.set(0, 0);
						this.tFov = _normalFOV;
					}

					this.current.x += (this.target.x - this.current.x) * delta * camSpeed;
					this.current.y += (this.target.y - this.current.y) * delta * camSpeed;
					this.cFov += (this.tFov - this.cFov) * delta * fovSpeed;

					let pos = new THREE.Vector3(
						this.current.x * _camPosFactor,
						this.current.y * _camPosFactor,
						_camPos
					);
					let look = new THREE.Vector3(
						this.current.x * _camLookFactor,
						this.current.y * _camLookFactor,
						_camLookPos
					);

					camera.position.set(pos.x, pos.y, pos.z);
					camera.lookAt(look.x, look.y, look.z);
					camera.fov = this.cFov;
					camera.updateProjectionMatrix();
				}
			}

			function init() {
				renderer = new THREE.WebGLRenderer({
					antialias: _antialias
				});
				renderer.setPixelRatio( window.devicePixelRatio );
	      renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(_fogColor, 1);
	      document.body.appendChild(renderer.domElement);
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(_fogColor, 0, _tunnelLength - 20);
	      camera = new THREE.PerspectiveCamera(
					45,
					window.innerWidth / window.innerHeight,
					0.1,
					50
				);
				clock = new THREE.Clock();
				elapsed = Math.random() * 20;

				light = new THREE.PointLight(_lightColor, 1, 150, 2);
				light.position.set(0, 0, -100);
				scene.add(light);

				tunnel = new Tunnel();
				handler = new MouseHandler();
			}

      function animate() {
      	requestAnimationFrame(animate);

				let delta = clock.getDelta();
				if (delta > 100) return;
				elapsed += delta;
				currentRadius = 1.5 + 0.1 * Math.sin(elapsed) +
															0.05 * Math.sin(elapsed*1.2) +
															0.05 * Math.sin(elapsed*1.3) +
															0.05 * Math.sin(elapsed*0.5) +
															0.05 * Math.sin(elapsed*1.9);
				//updateCamera(delta);
				tunnel.update(delta);
				handler.update(delta);

      	renderer.render(scene, camera);
      }

			function generateRing(n) {
				let res = [];
				res.n = n;
				const da = Math.PI * 2 / _ringSegments;
				for (let i = 0, a = (n == 0) ? 0 : da / 2; i < _ringSegments; i++, a += da) {
					let r = currentRadius - Math.random() * _randomNumR;
					let v = new THREE.Vector3(
						Math.cos(a) * r,
						Math.sin(a) * r,
						(Math.random() * 2 - 1) * _randomNumZ
					);
					res.push(v);
				}
				return res;
			}

			function generateSectionVerts(r1, r2, len) {
				let res = [];

				for (let i = 0; i < _ringSegments; i++) {
					let v = [
						new THREE.Vector3(r1[i].x, r1[i].y, r1[i].z + len / 2),
						new THREE.Vector3(
							r1[(i + 1) % _ringSegments].x,
							r1[(i + 1) % _ringSegments].y,
							r1[(i + 1) % _ringSegments].z + len / 2
						),
						new THREE.Vector3(r2[i].x, r2[i].y, r2[i].z - len / 2),
						new THREE.Vector3(
							r2[(i + 1) % _ringSegments].x,
							r2[(i + 1) % _ringSegments].y,
							r2[(i + 1) % _ringSegments].z - len / 2
						)
					];

					if (i % 2 == 0) {
						res.push(
							[v[0], v[1], v[2]],
							[v[1], v[2], v[3]]
						);
					} else {
						res.push(
							[v[0], v[2], v[3]],
							[v[0], v[1], v[3]]
						);
					}
				}

				return res;
			}

			function between(pair, n) {
        return n * (pair[1] - pair[0]) + pair[0];
      }

			var scene, camera, renderer, clock, handler;
			var elapsed;
			var tunnel, light;

			var currentRadius = 1.5;

			init();
      animate();
		</script>
	</body>
</html>
