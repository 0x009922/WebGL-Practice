<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Tunnel</title>
		<style>
			@font-face {
				font-family: "Monofur";
				src: url("fonts/Monofur.ttf");
			}
			@keyframes fadein {
				from {opacity: 0}
				to {opacity: 1}
			}
			@keyframes fadeout {
				from {opacity: 1}
				to {opacity: 0}
			}
			* {
				box-sizing: border-box;
				color: #00ff7f;
				font-family: Monofur, monospace;
				font-weight:  300;
			}
			body { margin: 0; overflow: hidden; background: black; }
			canvas {
				width: 100vw;
				height: 100vh;
				z-index: 10;
				opacity: 0;
				animation: fadein 3s ease-in;
				animation-fill-mode: forwards;
			}
			#meeting-container {
				position: absolute;
				top: 0;
				left: 0;
				background: black;
				width: 100vw;
				height: 100vh;
				display: flex;
				opacity: 1;
				justify-content: center;
				animation-fill-mode: forwards;
				animation-delay: 1s;
			}
			#cont2 {
				height: 100vh;
				background: #00ff7f10;
				animation: fadein 0.3s ease-in-out;
				opacity: 0;
				animation-fill-mode: forwards;
				animation-delay: 0.1s;
			}

			.box {
				background: transparent;
				width: 750px;
				margin: 0px 20px;
				font-size: 1.6em;
			}
			.box h1 {
				font-size: 2.6em;
			}
			.box block {
				display: block;
				margin-bottom: 20px;
			}
			.box warning {
				color: #B22222;
			}
			.box key {
				background: #00ff7f;
				color: black;
				padding: 10px 6px 0px 6px;
				border-radius: 3px;
			}
			.box high {
				background: #00ff7f30;
				padding: 8px 6px 0px 6px;
			}

			button {
				border: 2px solid #00ff7f;
        border-radius: 2px;
        background: transparent;
        color: #00ff7f;
        padding: 15px 15px 0 15px;
        width: 250px;
				font-size: 1.5em;
				margin-bottom: 20px;
				transition: all 0.15s ease-in-out;
      }
      button:focus {
        outline: 0;
      }
			button:hover {
				background: #00ff7f20;
			}
			button:active {
				background: #00ff7f40;
			}
			button.red {
				border: 2px solid #B22222;
				color: #b22222;
			}
			button.red:hover {
				background: #b2222220;
			}
			button.red:active {
				background: #b2222240;
			}

			#aa-cont {
				display: grid;
				grid-template-columns: 1fr 1fr 1fr;
				margin-bottom: 30px;
			}
			#aa-header {
				grid-column: 1;
				display: flex;
				align-items: center;
				font-size: 1.5em;
			}
			#aa-switcher {
				grid-column: 3;
			}
			#go-box {
				display: flex;
				justify-content: center;
			}
		</style>
	</head>
	<body>
		<div id="meeting-container">
			<div id="cont2">
				<div class="box">
					<h1>Привет</h1>
					<block>
						Для начала разверни страницу на весь экран, нажми <key>F11</key></br>
						Так будет лучше
					</block>
					<block>
						Если что-то вдруг пойдёт не так, ты можешь вернуться сюда,
						обновив страницу или просто нажав <key>F5</key>
					</block>
					<block><high>Воспользуйся мышью</high>, когда всё начнётся. Если хочешь</block>
					<block>
						Перед стартом мне нужно знать, использовать ли <high>сглаживание</high>?
						Так будет чуть красивее, но <warning>это потребует больше сил</warning>,
						поэтому если хочешь проверить браузер на прочность, то включай
					</block>

					<div id="aa-cont">
						<div id="aa-header">
							СГЛАЖИВАНИЕ
						</div>
						<button class="red" id="aa-switcher">Выкл</button>
					</div>

					<block>Не умею говорить заключительное слово, так что просто запускай уже</block>
					<div id="go-box"><button id="go">START</button></div>
				</div>
			</div>

		</div>

		<script src="../js/three.js"></script>
		<script>
			const _camLookPos = -7;
			const _camLookFactor = 2;
			const _camPos = -2;
			const _camPosFactor = -1;
			const _camTargetSpeed = 2;
			const _camRelaxationSpeed = 1;
			const _normalFOV = 35;
			const _minFOV = 10;
			const _maxFOV = 70;
			const _fovTargetSpeed = 2;
			const _fovRelaxationSpeed = 1;

			const _ringSegments = 60;
			const _randomNumR = 0.3;
			const _randomNumZ = 0.3;
			const _sectionLength = [0.5, 2];
			const _tunnelLength = 65;
			const _speed = 5;
			const _rotationSpeed = 0.2;

			const _secSize = _ringSegments * 6 * 3;
			const _bufferSize = _secSize * 1000;

			const _tunnelColor = 0;
			const _lightColor = 0x00ff7f;
			const _fogColor = 0x00ff7f;
			var _antialias = false;

			class Tunnel {
				constructor() {
					this.buffer = new BufferMaster();

					this.rings = [generateRing(1)];
					this.secs = [];
					let i = 0;
					let totalLength = 0;
					let z = 0;
					while (totalLength < _tunnelLength) {
						this.rings.push(generateRing(i % 2));
						let len = between(_sectionLength, Math.random());
						this.secs.push({length: len, start: z});
						this.buffer.push(generateSectionVerts(
							this.rings[i],
							this.rings[i + 1],
							len
						), z - len / 2);

						z -= len;
						i++;
						totalLength += len;
					}

					let g = new THREE.BoxGeometry(1, 1, 1);

					let mtrl = new THREE.MeshPhysicalMaterial({
						color: _tunnelColor,
						clearCoat: 0.5,
						clearCoatRoughness: 1,
						reflectivity: 0.5,
						side: THREE.DoubleSide
					});
					this.buffer.update();
					this.mesh = new THREE.Mesh(this.buffer.geometry, mtrl);

					scene.add(this.mesh);
					scene.add(new THREE.AxesHelper(15, 15, 15));
				}

				update(delta) {
					this.mesh.position.z += _speed * delta;
					this.mesh.rotation.z += _rotationSpeed * delta;
					let currentLength = this.secs.reduce((s, c) => (s + c.length), 0);

					if (this.mesh.position.z > this.secs[0].length) {
						this.mesh.position.z -= this.secs[0].length;
						currentLength -= this.secs[0].length;
						this.buffer.remove(1, this.secs[0].length);
						for (let i of this.secs) i.start += this.secs[0].length;
						this.secs.splice(0, 1);
						this.rings.splice(0, 1);
					}

					let lastSec = this.secs[this.secs.length - 1];
					while (this.mesh.position.z - currentLength > -_tunnelLength) {
						let rcount = this.rings.length;
						let nLen = between(_sectionLength, Math.random());

						this.rings.push(generateRing( (this.rings[rcount - 1].n + 1) % 2 ));
						lastSec = {
							length: nLen,
							start: lastSec.start - lastSec.length
						};
						this.secs.push(lastSec);

						this.buffer.push(
							generateSectionVerts(
								this.rings[rcount - 1],
								this.rings[rcount],
								nLen
							),
							lastSec.start - nLen / 2
						);
						currentLength += nLen;
					}

					this.buffer.update();
				}
			}

			class BufferMaster {
				constructor() {
					this.geometry = new THREE.BufferGeometry();
					this.positions = new Float32Array(_bufferSize);

					this.geometry.addAttribute(
						"position",
						new THREE.BufferAttribute(this.positions, 3)
					);

					this.count = 0;
					this.needUpdate = false;
				}

				remove(n, remlen) {
					let positions = this.geometry.getAttribute("position").array;

					this.count -= n;
					for (let i = 0, d = n * _secSize; i < this.count * _secSize; i++) {
						positions[i] = positions[i + d];
						if (i % 3 == 2) {
							positions[i] += remlen;
						}
					}

					this.needUpdate = true;
				}

				push(verts, z) {
					let positions = this.geometry.getAttribute("position").array;

					let bi = this.count * _secSize;
					for (let i = 0; i < verts.length; i++) {
						for (let j = 0; j < 3; j++) {
							positions[bi++] = verts[i][j].x;
							positions[bi++] = verts[i][j].y;
							positions[bi++] = verts[i][j].z + z;
						}
					}

					this.count++;
					this.needUpdate = true;
				}

				update() {
					if (this.needUpdate) {
						this.geometry.computeBoundingSphere();
						this.geometry.computeVertexNormals();
						this.geometry.getAttribute("position").needsUpdate = true;
						this.geometry.setDrawRange(0, this.count * _secSize / 3);
						this.needUpdate = false;
					}
				}
			}

			class MouseHandler {
				constructor() {
					this.target = new THREE.Vector2();
					this.current = new THREE.Vector2();
					this.targetSpeed = _camTargetSpeed;

					this.tFov = _normalFOV;
					this.cFov = _normalFOV;
					this.fovSpeed = _fovTargetSpeed;

					document.body.addEventListener("mousemove", this.onMove.bind(this), false);
					document.body.addEventListener("mousedown", this.onDown.bind(this), false);
					document.body.addEventListener("mouseup", this.onUp.bind(this), false);
					document.body.addEventListener("mouseleave", this.onLeave.bind(this), false);
					document.body.oncontextmenu = () => false;
					this.mousestatus = 0;
				}

				onMove(e) {
					if (this.mousestatus > 0 && this.mousestatus < 4)
						this._setTarget(e);
				}

				onDown(e) {
					this.mousestatus += e.which;
					this._setTarget(e);
				}

				onUp(e) {
					this.mousestatus -= e.which;
					if (this.mousestatus < 0) this.mousestatus = 0;
				}

				onLeave(e) {
					this.mousestatus = 0;
				}

				_setTarget(e) {
					this.target.set(
						(e.pageX / window.innerWidth * 2 - 1),
						-(e.pageY / window.innerHeight * 2 - 1)
					);
				}

				update(delta) {
					let fovSpeed, camSpeed;

					if (this.mousestatus > 0 && this.mousestatus < 4) {
						fovSpeed = _fovTargetSpeed;
						camSpeed = _camTargetSpeed;
						this.tFov = (this.mousestatus == 1) ? _minFOV : _maxFOV;
					} else {
						fovSpeed = _fovRelaxationSpeed;
						camSpeed = _camRelaxationSpeed;
						this.target.set(0, 0);
						this.tFov = _normalFOV;
					}

					this.current.x += (this.target.x - this.current.x) * delta * camSpeed;
					this.current.y += (this.target.y - this.current.y) * delta * camSpeed;
					this.cFov += (this.tFov - this.cFov) * delta * fovSpeed;

					let pos = new THREE.Vector3(
						this.current.x * _camPosFactor,
						this.current.y * _camPosFactor,
						_camPos
					);
					let look = new THREE.Vector3(
						this.current.x * _camLookFactor,
						this.current.y * _camLookFactor,
						_camLookPos
					);

					camera.position.set(pos.x, pos.y, pos.z);
					camera.lookAt(look.x, look.y, look.z);
					camera.fov = this.cFov;
					camera.updateProjectionMatrix();
				}
			}

			function init() {
				renderer = new THREE.WebGLRenderer({
					antialias: _antialias
				});
				renderer.setPixelRatio( window.devicePixelRatio );
	      renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(_fogColor, 1);
	      document.body.appendChild(renderer.domElement);
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(_fogColor, 0, _tunnelLength - 20);
	      camera = new THREE.PerspectiveCamera(
					45,
					window.innerWidth / window.innerHeight,
					0.1,
					50
				);
				clock = new THREE.Clock();
				elapsed = Math.random() * 20;

				light = new THREE.PointLight(_lightColor, 1, 150, 2);
				light.position.set(0, 0, -100);
				scene.add(light);

				tunnel = new Tunnel();
				handler = new MouseHandler();
			}

      function animate() {
      	requestAnimationFrame(animate);

				let delta = clock.getDelta();
				if (delta > 100) return;
				elapsed += delta;
				currentRadius = 1.5 + 0.1 * Math.sin(elapsed) +
															0.05 * Math.sin(elapsed*1.2) +
															0.05 * Math.sin(elapsed*1.3) +
															0.05 * Math.sin(elapsed*0.5) +
															0.05 * Math.sin(elapsed*1.9);
				//updateCamera(delta);
				tunnel.update(delta);
				handler.update(delta);

      	renderer.render(scene, camera);
      }

			function generateRing(n) {
				let res = [];
				res.n = n;
				const da = Math.PI * 2 / _ringSegments;
				for (let i = 0, a = (n == 0) ? 0 : da / 2; i < _ringSegments; i++, a += da) {
					let r = currentRadius - Math.random() * _randomNumR;
					let v = new THREE.Vector3(
						Math.cos(a) * r,
						Math.sin(a) * r,
						(Math.random() * 2 - 1) * _randomNumZ
					);
					res.push(v);
				}
				return res;
			}

			function generateSectionVerts(r1, r2, len) {
				let res = [];

				for (let i = 0; i < _ringSegments; i++) {
					let v = [
						new THREE.Vector3(r1[i].x, r1[i].y, r1[i].z + len / 2),
						new THREE.Vector3(
							r1[(i + 1) % _ringSegments].x,
							r1[(i + 1) % _ringSegments].y,
							r1[(i + 1) % _ringSegments].z + len / 2
						),
						new THREE.Vector3(r2[i].x, r2[i].y, r2[i].z - len / 2),
						new THREE.Vector3(
							r2[(i + 1) % _ringSegments].x,
							r2[(i + 1) % _ringSegments].y,
							r2[(i + 1) % _ringSegments].z - len / 2
						)
					];

					if (i % 2 == 0) {
						res.push(
							[v[0], v[1], v[2]],
							[v[1], v[2], v[3]]
						);
					} else {
						res.push(
							[v[0], v[2], v[3]],
							[v[0], v[1], v[3]]
						);
					}
				}

				return res;
			}

			function between(pair, n) {
        return n * (pair[1] - pair[0]) + pair[0];
      }

			var scene, camera, renderer, clock, handler;
			var elapsed;
			var tunnel, light;

			var currentRadius = 1.5;
			let switcher = document.getElementById("aa-switcher");

			switcher.onclick = () => {
				switch(switcher.className) {
					case "":
					switcher.className = "red";
					switcher.textContent = "Выкл";
					_antialias = false;
					break;
					case "red":
					switcher.className = "";
					switcher.textContent = "Вкл";
					_antialias = true;
					break;
				}
			}
			document.getElementById("go").onclick = () => {
				let el2 = document.getElementById("meeting-container");
				el2.style.animation = "fadeout 0.5s ease-out";
				el2.style.animationFillMode = "forwards";
				el2.style.animationDelay = "0s";
				setTimeout(() => {
					init();
					animate();
				}, 500);
			}
		</script>
	</body>
</html>
