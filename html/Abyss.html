<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Abyss</title>
		<style>
			@font-face {
				font-family: "Monofur";
				src: url("../src/fonts/Monofur.ttf");
			}
			@keyframes fadein {
				from {opacity: 0; transform: scale(1);}
				to {opacity: 1; transform: scale(1);}
			}
			@keyframes fadeout {
				from {opacity: 1; transform: scale(1);}
				to {opacity: 0; transform: scale(1.1);}
			}
			* {
				box-sizing: border-box;
				color: #00ff7f;
				font-family: Monofur;
				font-weight:  300;
				font-size: 27px;
				line-height: 1.25;
				user-select: none;
			}
			body {
				margin: 0;
				overflow: hidden;
				background: #363537;
				cursor: default;
			}
			button {
				cursor: pointer;
			}
			button:focus {
        outline: 0;
      }
			hr {
				background-color: #00ff7f;
				height: 2px;
				border: none;
				margin: 50px 0;
			}

			.center-box {
				display: flex;
				justify-content: center;
			}

			#render-dom {
				width: 100vw;
				height: 100vh;
				z-index: 10;
				opacity: 0;
				animation: fadein 3s ease-in;
				animation-fill-mode: forwards;
			}

			#meeting-container {
				position: absolute;
				top: 0;
				left: 0;
				background: #363537;
				width: 100vw;
				height: 100vh;
				display: flex;
				opacity: 1;
				justify-content: center;
				animation-fill-mode: forwards;
				animation-delay: 1s;
			}

			#cont2 {
				height: 100vh;
				background: transparent;
				animation: fadein 0.3s ease-in-out;
				opacity: 0;
				animation-fill-mode: forwards;
				animation-delay: 0.1s;
				overflow-y: auto;
			}
			#cont2::-webkit-scrollbar {
				width: 0;
			}

			.box {
				width: 650px;
				margin: 20px 0px;
			}
			.main-header {
				font-size: 7.5em;
				line-height: 0.75;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.main-header big {
				font-size: 1.35em;
				line-height: inherit;
			}
			.box block {
				display: block;
				margin-bottom: 20px;
			}
			.box key {
				background: #00ff7f;
				color: #363537;
				padding: 5px 5px;
				border-radius: 3px;
			}

			.info {
				margin-left: 20px;
			}

			.sets {

			}
			.sets .header {
				font-size: 2em;
				color: #3772FF;
				margin-bottom: 30px;
			}
			.switchers-box {
				display: grid;
				grid-template-columns: repeat(2, 1fr);
				grid-gap: 20px;
				justify-items: stretch;
			}

			.switchers-box button {
				border: 2px solid #3772ff;
				border-radius: 2px;
				font-size: 1.5em;
				height: 100px;
				transition: all 0.2s ease;
			}
			.switchers-box button[on="false"] {
				color: #3772FF;
				background: transparent;
			}
			.switchers-box button[on="true"] {
				color: #363537;
				background: #3772FF;
			}

			#start {
				border: 2px solid #00ff7f;
				border-radius: 2px;
				font-size: 1.5em;
				width: 150px;
				height: 80px;
				background: transparent;
				transition: all 0.2s ease;
				margin-bottom: 30px;
			}
			#start:hover {
				background: #00ff7f;
				color: #363537;
			}
			#start:active {
				background: #00ff7f80;
				color: #363537;
			}
		</style>
	</head>
	<body>
		<div id="meeting-container">
			<div id="cont2">
				<div class="box">
					<div class="center-box">
						<div class="main-header">AB<big>Y</big>SS</div>
					</div>

					<hr/>

					<div class="center-box">
						<button id="start" onclick="startClick()">START</button>
					</div>

					<div class="info" hidden>
						<block>
							<key>F5</key> - вернуться в меню.
						</block>
						<block>
							<key>F11</key> - полноэкранный режим.
						</block>
					</div>

					<div class="sets">
						<div class="header">Настройки</div>
						<div class="switchers-box">
							<button on="false" onclick="aaClick(this)">Сглаживание</button>
							<button on="false" onclick="ppClick(this)">Постобработка</button>
							<button on="false" onclick="stClick(this)">Статистика</button>
						</div>
					</div>
				</div>
			</div>

		</div>

		<script src="../js/three.js"></script>
		<script src="../js/stats.min.js"></script>
		<script>
			const _camLookPos = -7;
			const _camLookFactor = 2;
			const _camPos = -2;
			const _camPosFactor = -1;
			const _camTargetSpeed = 2;
			const _camRelaxationSpeed = 1;

			const _normalFOV = 35;
			const _leftFOV = 10;
			const _rightFOV = 70;
			const _fovTargetSpeed = 2;
			const _fovRelaxationSpeed = 1;

			const _colorTargetSpeed = 2;
			const _colorRelaxationSpeed = 5;

			const _ringSegments = 60;
			const _randomNumR = 0.3;
			const _randomNumZ = 0.3;
			const _sectionLength = [0.5, 2];
			const _tunnelLength = 65;
			const _speed = 5;
			const _rotationSpeed = 0.2;

			const _secSize = _ringSegments * 6 * 3;
			const _bufferSize = _secSize * 1000;

			const _tunnelColor = 0xffffff;
			const _normalColor = 0x00ff7f;
			const _leftColor = 0xDB3A34;
			const _rightColor = 0x3772FF;

			// settings
			var _antialias = false;
			var _postprocessing = false;
			var _stats = false;

			// vars
			var scene, camera, renderer, clock, handler, stats;
			var elapsed;
			var tunnel, light;
			var currentRadius = 1.5;

			class Tunnel {
				constructor() {
					this.buffer = new BufferMaster();

					this.rings = [generateRing(1)];
					this.secs = [];
					let i = 0;
					let totalLength = 0;
					let z = 0;
					while (totalLength < _tunnelLength) {
						this.rings.push(generateRing(i % 2));
						let len = between(_sectionLength, Math.random());
						this.secs.push({length: len, start: z});
						this.buffer.push(generateSectionVerts(
							this.rings[i],
							this.rings[i + 1],
							len
						), z - len / 2);

						z -= len;
						i++;
						totalLength += len;
					}

					let g = new THREE.BoxGeometry(1, 1, 1);

					let mtrl = new THREE.MeshPhongMaterial({
						color: _tunnelColor,
						diffuse: 1,
						shininess: 0,
						reflectivity: 1,
						specular: 0xffffff,
						side: THREE.DoubleSide
					});
					this.buffer.update();
					this.mesh = new THREE.Mesh(this.buffer.geometry, mtrl);

					scene.add(this.mesh);
					scene.add(new THREE.AxesHelper(15, 15, 15));
				}

				update(delta) {
					this.mesh.position.z += _speed * delta;
					this.mesh.rotation.z += _rotationSpeed * delta;
					let currentLength = this.secs.reduce((s, c) => (s + c.length), 0);

					if (this.mesh.position.z > this.secs[0].length) {
						this.mesh.position.z -= this.secs[0].length;
						currentLength -= this.secs[0].length;
						this.buffer.remove(1, this.secs[0].length);
						for (let i of this.secs) i.start += this.secs[0].length;
						this.secs.splice(0, 1);
						this.rings.splice(0, 1);
					}

					let lastSec = this.secs[this.secs.length - 1];
					while (this.mesh.position.z - currentLength > -_tunnelLength) {
						let rcount = this.rings.length;
						let nLen = between(_sectionLength, Math.random());

						this.rings.push(generateRing( (this.rings[rcount - 1].n + 1) % 2 ));
						lastSec = {
							length: nLen,
							start: lastSec.start - lastSec.length
						};
						this.secs.push(lastSec);

						this.buffer.push(
							generateSectionVerts(
								this.rings[rcount - 1],
								this.rings[rcount],
								nLen
							),
							lastSec.start - nLen / 2
						);
						currentLength += nLen;
					}

					this.buffer.update();
				}
			}

			class BufferMaster {
				constructor() {
					this.geometry = new THREE.BufferGeometry();
					this.positions = new Float32Array(_bufferSize);

					this.geometry.addAttribute(
						"position",
						new THREE.BufferAttribute(this.positions, 3)
					);

					this.count = 0;
					this.needUpdate = false;
				}

				remove(n, remlen) {
					let positions = this.geometry.getAttribute("position").array;

					this.count -= n;
					for (let i = 0, d = n * _secSize; i < this.count * _secSize; i++) {
						positions[i] = positions[i + d];
						if (i % 3 == 2) {
							positions[i] += remlen;
						}
					}

					this.needUpdate = true;
				}

				push(verts, z) {
					let positions = this.geometry.getAttribute("position").array;

					let bi = this.count * _secSize;
					for (let i = 0; i < verts.length; i++) {
						for (let j = 0; j < 3; j++) {
							positions[bi++] = verts[i][j].x;
							positions[bi++] = verts[i][j].y;
							positions[bi++] = verts[i][j].z + z;
						}
					}

					this.count++;
					this.needUpdate = true;
				}

				update() {
					if (this.needUpdate) {
						this.geometry.computeBoundingSphere();
						this.geometry.computeVertexNormals();
						this.geometry.getAttribute("position").needsUpdate = true;
						this.geometry.setDrawRange(0, this.count * _secSize / 3);
						this.needUpdate = false;
					}
				}
			}

			class MouseHandler {
				constructor() {
					this.target = new THREE.Vector2();
					this.current = new THREE.Vector2();
					this.targetSpeed = _camTargetSpeed;

					this.tFov = _normalFOV;
					this.cFov = _normalFOV;
					this.fovSpeed = _fovTargetSpeed;

					this.normCol = toRGB(_normalColor);
					this.leftCol = toRGB(_leftColor);
					this.rightCol = toRGB(_rightColor);

					this.tColor = toRGB(_normalColor);
					this.cColor = toRGB(_normalColor);
					this.colorSpeed = _colorTargetSpeed;

					document.body.addEventListener("mousemove", this.onMove.bind(this), false);
					document.body.addEventListener("mousedown", this.onDown.bind(this), false);
					document.body.addEventListener("mouseup", this.onUp.bind(this), false);
					document.body.addEventListener("mouseleave", this.onLeave.bind(this), false);
					document.body.oncontextmenu = () => false;
					this.mousestatus = 0;
				}

				onMove(e) {
					if (this.mousestatus > 0 && this.mousestatus < 4)
						this._setTarget(e);
				}

				onDown(e) {
					this.mousestatus += e.which;
					this._setTarget(e);
				}

				onUp(e) {
					this.mousestatus -= e.which;
					if (this.mousestatus < 0) this.mousestatus = 0;
				}

				onLeave(e) {
					this.mousestatus = 0;
				}

				_setTarget(e) {
					this.target.set(
						(e.pageX / window.innerWidth * 2 - 1),
						-(e.pageY / window.innerHeight * 2 - 1)
					);
				}

				update(delta) {
					let fovSpeed, camSpeed, colorSpeed;

					if (this.mousestatus > 0 && this.mousestatus < 4) {
						fovSpeed = _fovTargetSpeed;
						camSpeed = _camTargetSpeed;
						colorSpeed = _colorTargetSpeed;
						let col = (this.mousestatus == 1) ? this.leftCol : this.rightCol;
						this.tColor.r = col.r;
						this.tColor.g = col.g;
						this.tColor.b = col.b;
						this.tFov = (this.mousestatus == 1) ? _leftFOV : _rightFOV;
					} else {
						fovSpeed = _fovRelaxationSpeed;
						camSpeed = _camRelaxationSpeed;
						colorSpeed = _colorRelaxationSpeed;
						this.tColor.r = this.normCol.r;
						this.tColor.g = this.normCol.g;
						this.tColor.b = this.normCol.b;
						this.target.set(0, 0);
						this.tFov = _normalFOV;
					}

					this.current.x += (this.target.x - this.current.x) * delta * camSpeed;
					this.current.y += (this.target.y - this.current.y) * delta * camSpeed;
					this.cFov += (this.tFov - this.cFov) * delta * fovSpeed;
					this.cColor.r += (this.tColor.r - this.cColor.r) * delta * colorSpeed;
					this.cColor.g += (this.tColor.g - this.cColor.g) * delta * colorSpeed;
					this.cColor.b += (this.tColor.b - this.cColor.b) * delta * colorSpeed;

					let pos = new THREE.Vector3(
						this.current.x * _camPosFactor,
						this.current.y * _camPosFactor,
						_camPos
					);
					let look = new THREE.Vector3(
						this.current.x * _camLookFactor,
						this.current.y * _camLookFactor,
						_camLookPos
					);

					camera.position.set(pos.x, pos.y, pos.z);
					camera.lookAt(look.x, look.y, look.z);
					camera.fov = this.cFov;
					camera.updateProjectionMatrix();

					let hex = toHex(this.cColor)
					scene.fog.color.setHex(hex);
					renderer.setClearColor(hex, 1);
					light.color.set(hex);
				}
			}

			function init() {
				renderer = new THREE.WebGLRenderer({
					antialias: _antialias
				});
				renderer.setPixelRatio( window.devicePixelRatio );
	      renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(_normalColor, 1);
				renderer.domElement.id = "render-dom";
	      document.body.appendChild(renderer.domElement);
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(_normalColor, 0, _tunnelLength - 20);
	      camera = new THREE.PerspectiveCamera(
					45,
					window.innerWidth / window.innerHeight,
					0.1,
					50
				);
				clock = new THREE.Clock();
				elapsed = Math.random() * 20;

				light = new THREE.PointLight(_normalColor, 3, 150, 2);
				light.position.set(0, 0, -100);
				scene.add(light);

				tunnel = new Tunnel();
				handler = new MouseHandler();
				if (_stats) {
					stats = new Stats();
					document.body.appendChild(stats.dom);
				}
			}

      function animate() {
      	requestAnimationFrame(animate);

				let delta = clock.getDelta();
				if (delta > 100) return;
				elapsed += delta;
				currentRadius = 1.5 + 0.1 * Math.sin(elapsed) +
															0.05 * Math.sin(elapsed*1.2) +
															0.05 * Math.sin(elapsed*1.3) +
															0.05 * Math.sin(elapsed*0.5) +
															0.05 * Math.sin(elapsed*1.9);
				//updateCamera(delta);
				tunnel.update(delta);
				handler.update(delta);
				if (stats)
					stats.update();

      	renderer.render(scene, camera);
      }

			function generateRing(n) {
				let res = [];
				res.n = n;
				const da = Math.PI * 2 / _ringSegments;
				for (let i = 0, a = (n == 0) ? 0 : da / 2; i < _ringSegments; i++, a += da) {
					let r = currentRadius - Math.random() * _randomNumR;
					let v = new THREE.Vector3(
						Math.cos(a) * r,
						Math.sin(a) * r,
						(Math.random() * 2 - 1) * _randomNumZ
					);
					res.push(v);
				}
				return res;
			}

			function generateSectionVerts(r1, r2, len) {
				let res = [];

				for (let i = 0; i < _ringSegments; i++) {
					let v = [
						new THREE.Vector3(r1[i].x, r1[i].y, r1[i].z + len / 2),
						new THREE.Vector3(
							r1[(i + 1) % _ringSegments].x,
							r1[(i + 1) % _ringSegments].y,
							r1[(i + 1) % _ringSegments].z + len / 2
						),
						new THREE.Vector3(r2[i].x, r2[i].y, r2[i].z - len / 2),
						new THREE.Vector3(
							r2[(i + 1) % _ringSegments].x,
							r2[(i + 1) % _ringSegments].y,
							r2[(i + 1) % _ringSegments].z - len / 2
						)
					];

					if (i % 2 == 0) {
						res.push(
							[v[0], v[1], v[2]],
							[v[1], v[2], v[3]]
						);
					} else {
						res.push(
							[v[0], v[2], v[3]],
							[v[0], v[1], v[3]]
						);
					}
				}

				return res;
			}

			function between(pair, n) {
        return n * (pair[1] - pair[0]) + pair[0];
      }

			function toHex(c) {
				return (c.r << 16) + (c.g << 8) + c.b;
			}
			function toRGB(hex) {
				return {
					r: hex >> 16,
					g: (hex & 0xff00) >> 8,
					b: hex & 0xff
				}
			}

			function aaClick(el) {
				let on = el.getAttribute("on") == "false";
				_antialias = on;
				el.setAttribute("on", on);
			}
			function ppClick(el) {
				let on = el.getAttribute("on") == "false";
				_postprocessing = on;
				el.setAttribute("on", on);
			}
			function stClick(el) {
				let on = el.getAttribute("on") == "false";
				_stats = on;
				el.setAttribute("on", on);
			}
			function startClick() {
				let el2 = document.getElementById("meeting-container");
				el2.style.animation = "fadeout 0.5s ease-out";
				el2.style.animationFillMode = "forwards";
				el2.style.animationDelay = "0s";
				setTimeout(() => {
					init();
					animate();
				}, 500);
			}
		</script>
	</body>
</html>
